---
title: "useR to programmeR"
subtitle: "Iteration 1"
author: "Emma Rand and Ian Lyttle"
format: 
  revealjs:
    theme: [simple]
    slide-number: true
    chalkboard: true
    code-link: true
    code-line-numbers: false
bibliography: references.bib
---

# Overview

## Overview

brief intro

## Learning Objectives

At the end of this section you will be able to:

::: {style="font-size: 70%;"}

-   recognise that much iteration comes free with R

-   iterate across rows using `across()`
    -   use selection functions to select columns for iteration
    -   use anonymous functions to pass arguments
    -   use anonymous functions give more than one function
    -   use `.names` to control the output

-   use `across()` in functions

:::

## What is iteration?

Iteration means repeating steps multiple times until a condition is met

In other languages, all iteration is performed with loops: `for`, `while`

. . .

Iteration is different in R because 

It is functional programming language. You *can* use loops....... bit you often don't *need* to 


## Iteration in R

-   iteration is an inherent part of the language

-   the `apply()` family

-   `group_by()` with `summarize()`

-   `facet_wrap()`

-   `across()` and `purrr()`

## Iteration in R

Part of the language. For example, if

```{r}
nums <- c(3, 1, 6, 4)

```

Then

```{r}
#| eval: false
2 * nums
```

is

## Iteration in R

``` r
[1]  6  2 12  8
```

and NOT

. . .

``` r
[1]  6  2 12  8  6  2 12  8
```

other languages, a for loop would be right after hello world



## Functional programming

"functional programming" because functions take other functions as input

-   modifying multiple columns {dplyr}

-   reading multiple files {purrr}

-   saving multiple outputs {purrr}

# Set up

## Create a `.R`

```{r}
#| eval: false

usethis::use_r("functions-01")
```

## Packages

ðŸŽ¬ Load packages:

```{r}
library(tidyverse)
library(palmerpenguins)
```

```         
â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€
âœ” dplyr     1.1.2     âœ” readr     2.1.4
âœ” forcats   1.0.0     âœ” stringr   1.5.0
âœ” ggplot2   3.4.2     âœ” tibble    3.2.1
âœ” lubridate 1.9.2     âœ” tidyr     1.3.0
âœ” purrr     1.0.1     â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
âœ– dplyr::filter() masks stats::filter()
âœ– dplyr::lag()    masks stats::lag()
â„¹ Use the conflicted package to force all conflicts to become errors'
```

## Load `penguins`

ðŸŽ¬ Load `penguins` data set

```{r}
data(penguins)
glimpse(penguins)

```

# Modifying multiple columns

## Scenario

Recall our standard error function from this morning:

```{r}
sd_error <- function(x){
  sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
}
```

## Scenario

Which we might use as:

```{r}
penguins |> 
  summarise(se_bill_len = sd_error(bill_length_mm),
            se_bill_dep = sd_error(bill_depth_mm),
            se_flip_len = sd_error(flipper_length_mm ),
            se_body_mas = sd_error(body_mass_g))
```

. . .

âš ï¸ Code repetition!

How can we iterate over rows?

## Solution: `across()`

```{r}
penguins |> 
  summarise(across(bill_length_mm:body_mass_g, sd_error))
```

## `across()` Arguments

`across(.cols, .fns, .names)`

3 important arguments

-   which columns you want to iterate over: `.cols = bill_length_mm:body_mass_g`

## `across()` Arguments

-   what you want to do to each column: `.fns = sd_error`

    -   single function
    -   include arguments to that function
    -   more than one function

## `across()` Arguments

-   `.names` to control output

## selecting columns with `.cols`

-   we could use colon notation, `bill_length_mm:body_mass_g`, because columns are adjacent

. . . 

but


-   `.cols` uses same specification as `select()`: `starts_with()`, `ends_with()`, `contains()`, `matches()`

## selecting columns with `.cols`

```{r}
penguins |> 
  summarise(across(ends_with("mm"), sd_error))
```

## selecting columns with `.cols`

-   `everything()`: all non-grouping columns

```{r}
penguins |> 
  group_by(species, island, sex) |> 
  summarise(across(everything(), sd_error))
```

## selecting columns with `.cols`

```{r}
#| eval: false
penguins |> 
  group_by(species, island, sex) |> 
  summarise(across(everything(), sd_error))
```

-  variables in `group_by()` are excluded

-  all of `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, `body_mass_g`, `year`

## selecting columns with `.cols`

-   `everything()`: all non-grouping columns without year

```{r}
penguins |> 
  select(-year) |>
  group_by(species, island, sex) |> 
  summarise(across(everything(), sd_error))
```

## selecting columns with `.cols`

-   My columns have very different names and I don't want to group!

. . .

-   all the *numeric* columns: `where()`

```{r}
penguins |> 
  select(-year) |>
  summarise(across(where(is.numeric), sd_error))
```


## `.funs`: calling one function

-   we can pass a function, `sd_error` to `across()` since R is a functional programming language

-   note, we are not calling `sd_error()`

-   instead we pass `sd_error` so `across()` can call it

-   thus function name is **not** followed by `()`

## function name is **not** followed by `()`

```{r}
#| error: true
penguins |> 
  select(-year) |>
  summarise(across(where(is.numeric), sd_error()))
```

## Include arguments

```{r}
penguins |> 
  summarise(across(ends_with("mm"), mean))
```


We get the NA because we have missing values[^1].

## Include arguments

`mean()` has an `na.rm` argument. 

How can we pass on `na.rm = TRUE`?

. . .


```{r}
#| error: true
penguins |> 
  summarise(across(ends_with("mm"), mean(na.rm = TRUE)))
```

## Include arguments

The solution is to create a new function that calls `mean()` with `na.rm = TRUE`

. . .

```{r}
penguins |> 
  summarise(across(ends_with("mm"), 
                   function(x) mean(x, na.rm = TRUE)))
```

`mean` is replaced by a function definition


## Anonymous functions

```r
penguins |> 
  summarise(across(ends_with("mm"), 
                   function(x) mean(x, na.rm = TRUE)))
```

-   This is called an **anonymous** or **lambda** function.

-   It is anonymous because we do not give it a name with `<-`

## Anonymous functions

Shorthand

. . . 

Instead of writing `function` we can use `\`

```{r}
penguins |> 
  summarise(across(ends_with("mm"), \(x) mean(x, na.rm = TRUE)))
```



## `.funs`: calling more than one function

How can we use more than one function across the columns?


```r
penguins |> 
  summarise(across(ends_with("mm"), _MORE THAN ONE FUNCTION_))
```

. . .


by using a list


## `.funs`: calling more than one function

```r
penguins |> 
  summarise(across(ends_with("mm"), list(
    \(x) mean(x, na.rm = TRUE),
    \(x) sd(x, na.rm = TRUE))))
```


## `.funs`: calling more than one function

```{r}
penguins |> 
  summarise(across(ends_with("mm"), list(
    \(x) mean(x, na.rm = TRUE),
    \(x) sd(x, na.rm = TRUE))))
```

. . .

Output: the `_1` and `_2` are not very useful.

## `.funs`: calling more than one function

We can improve with naming the elements in the list

```{r}
penguins |> 
  summarise(across(ends_with("mm"), list(
    mean = \(x) mean(x, na.rm = TRUE),
    sdev = \(x) sd(x, na.rm = TRUE))))
```

. . .

The column name is `{.col}_{.fn}`: `bill_length_mm_mean`

. . .

We can change using `.names`

## `.names` to control output

```{r}
penguins |> 
  summarise(across(ends_with("mm"),
                   list(mean = \(x) mean(x, na.rm = TRUE),
                        sdev = \(x) sd(x, na.rm = TRUE)),
                   .names = "{.fn}_of_{.col}"))
```

## `.names` to control output

Especially important for `mutate()`.

Recall our `to_z()` function

```{r}
to_z <- function(x, middle = 1) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

## `to_z()` function in `mutate()`

which we used like this

```{r}
penguins |>
  mutate(
    z_bill_length_mm = to_z(bill_length_mm),
    z_bill_depth_mm = to_z(bill_depth_mm),
    z_flipper_length_mm = to_z(flipper_length_mm)
  ) |> 
  glimpse()
```

## `.names` to control output

```{r}
penguins |>
  mutate(across(ends_with("mm"),
                to_z)
  ) |> 
  glimpse()
```

ðŸ˜®  Results go into existing columns!

## 

```{r}
penguins |>
  mutate(across(ends_with("mm"),
                to_z,
                .names = "z_{.col}")
  ) |> 
  glimpse()
```

## A note on dots in argument names

-   

-   

## Iteration over columns in `filter()`

??

## `across()` in functions

```{r}
my_summary <- function(df, cols){
  df |> 
    summarise(across({{cols}},
                     list(mean = \(x) mean(x, na.rm = TRUE),
                          sdev = \(x) sd(x, na.rm = TRUE)),
                     .names = "{.fn}_of_{.col}"),
              .groups = "drop")
}

```

```{r}
my_summary(penguins, ends_with("mm"))
```

```{r}
my_summary <- function(df, cols = where(is.numeric)){
  df |> 
    summarise(across({{cols}},
                     list(mean = \(x) mean(x, na.rm = TRUE),
                          sdev = \(x) sd(x, na.rm = TRUE)),
                     .names = "{.fn}_of_{.col}"),
              .groups = "drop")
}

```

```{r}
my_summary(penguins)
```

## Your turn



## Summary


-   
-   
-   
-   



[^1]: There is no problem when we use `sd_error()` because we accounted for NA in our function definition
