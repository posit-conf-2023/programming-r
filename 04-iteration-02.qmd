---
title: "Iteration: Part 2"
format: revealjs
---

## Reading multiple files


## Saving multiple outputs

## Extras

Three fundamental operations in functional programming

Given an array and a function:

 - `map()`:  make a new list, operating on each element
 - `filter()`: make a new list, subset of old list
 - `reduce()`: make a new "thing"

## dplyr using purrr?
 
We can use these three operations to "implement", using purrr:

 - `dplyr::mutate()`
 - `dplyr::filter()`
 - `dplyr::summarise()`

I claim it's possible, I don't claim it's a good idea.

## `dpurrr_filter()`

```{r}
library("tidyverse")

dpurrr_filter <- function(df, predicate) {
  df |>
    as.list() |>
    purrr::list_transpose(simplify = FALSE) |>
    purrr::keep(predicate) |>
    purrr::list_transpose() |>
    as.data.frame() 
}
```

<hr>

```{r}
dpurrr_filter(mtcars, \(x) x$gear == 3) |> head()
```

## `dpurrr_mutate()`

```{r}
dpurrr_mutate <- function(df, mapper) {
  df |>
    as.list() |>
    purrr::list_transpose(simplify = FALSE) |>
    purrr::map(\(x) c(x, mapper(x))) |>
    purrr::list_transpose() |>
    as.data.frame() 
}
```

<hr>

```{r}
mtcars |> 
  dpurrr_mutate(\(x) list(wt_kg = x$wt * 1000 / 2.2)) |> 
  head()
```

## `dpurrr_summarise()`

```{r}
dpurrr_summarise <- function(df, reducer, .init) {
  df |>
    as.list() |>
    purrr::list_transpose(simplify = FALSE) |>
    purrr::reduce(reducer, .init = .init) |>
    as.data.frame()
}
```

<hr>

```{r}
mtcars |> 
  dpurrr_summarise(
    \(acc, val) list(
      wt_min = min(acc$wt_min, val$wt), 
      wt_max = max(acc$wt_max, val$wt)
    ),
    .init = list(wt_min = Inf, wt_max = -Inf)
  )
```

## With grouping

First, a little prep work:

```{r}
ireduce <- function(x, reducer, .init) {
  purrr::reduce2(x, names(x), reducer, .init = .init)
}

summarizer <- function(df) {
  df |> 
    dpurrr_summarise(
      \(acc, val) list(
        wt_min = min(acc$wt_min, val$wt), 
        wt_max = max(acc$wt_max, val$wt)
      ),
      .init = list(wt_min = Inf, wt_max = -Inf)
    )  
}
```

## Et voilÃ 

```{r}
mtcars |> 
  split(mtcars$gear) |>
  purrr::map(summarizer) |> 
  ireduce( 
    \(acc, x, y) rbind(acc, c(list(gear = y), x)),
    .init = data.frame()
  ) 
```

I think we can agree this presents no danger to dplyr.

In JavaScript, data frames are often arrays of objects (lists), so you'll see formulations like this (e.g. **tidyjs**).
