---
title: "useR to programmeR"
subtitle: "üëã & Functions 1"
author: "Emma Rand and Ian Lyttle"
format: 
  revealjs:
    theme: [simple, styles.scss]
    slide-number: true
    chalkboard: true
    code-link: true
    code-line-numbers: false
bibliography: references.bib
---

# üëã Welcome

## Introductions

This is a two-day, hands-on workshop for those who have embraced the tidyverse and want to improve their R programming skills and, especially, reduce the amount of duplication in their code.

-   do you have experience equivalent to an introductory data science course using tidyverse?
-   are you comfortable with the [Whole game](https://r4ds.hadley.nz/whole-game.html) chapter of [R for Data Science (2nd Edition)](https://r4ds.hadley.nz/) by by Hadley Wickham, Mine √áetinkaya-Rundel, and Garrett Grolemund.

\

### Material

-   <https://posit-conf-2023.github.io/programming-r/>

## The team

::: columns
::: {.column width="55%"}
Emma Rand

üêò[\@3mma\@mastodon.social](https://mastodon.social/@3mma)

Stephanie Hazlitt
:::

::: {.column width="45%"}
Ian Lyttle

üêò[\@ijlyttle\@vis.social](https://mastodon.social/@ijlyttle@vis.social)

Mouna Belaid
:::
:::

¬†

Standing on the shoulders of

::: {style="font-size: 80%;"}
-   [R for Data Science (2e)](https://r4ds.hadley.nz/) @wickham2023

-   [The tidyverse style guide](https://style.tidyverse.org/index.html) @wickham-style

-   [Programming with dplyr vignette](https://dplyr.tidyverse.org/articles/programming.html) @dplyr
:::

\

### WiFi TOFIX

-   Username: `conf22`
-   Password: `together!`

## Introductions

To each other!

## Code of Conduct TOFIX

[Full Code of Conduct](https://posit.co/code-of-conduct/). **Please Review**

-   üíô Treat everyone with respect
-   üß° Everyone should feel welcome and safe

Reporting:

-   üó£Ô∏è any posit::conf staff member (t-shirt) or Info desk
-   üìß `conf@posit.com`
-   ‚òéÔ∏è 844-448-1212

## Housekeeping TOFIX

-   WiFi:
    -   Username: `conf22`
    -   Password: `together!`
-   Gender neutral bathrooms xxxxxxxxx.
-   Meditation room xxxxx. 8am - 5pm, Monday - Thursday.
-   Lactation room xxxxx. 8am - 5pm, Monday - Thursday.
-   Participants who do not wish to be photographed have red lanyards

## üôè to

-   the Steph and Mouna

-   colleagues, friends and learners at Schneider Electric, University of York and RForwards!

-   Posit team and especially Mine √áetinkaya-Rundel

. . .

-   Ian!

. . .

-   Experience üç± ü•ó üåÆ üç¥ üïê

## Prerequisites TOFIX

You need a laptop with the following installed:

-   R version ‚â•4.2 and RStudio ‚â•2023.03
-   The following packages: {tidyverse}, {palmerpenguins}

üé¨ Detailed instructions for installing these were covered in [Prerequisites](pre-reqs.html)

## Schedule {.smaller}

| Time          | Activity                                                                                    |
|:----------------|:------------------------------------------------------|
| 09:00 - 10:30 | [Functions 1](01-functions-01.html) Introduction, vector and dataframe functions, embracing |
| 10:30 - 11:00 | ‚òï *Coffee break*                                                                           |
| 11:00 - 12:30 | [Functions 2](02-functions-02.html) Plot functions, style and side effects                  |
| 12:30 - 13:30 | üç± ü•ó üåÆ üç¥ *Lunch break*                                                                   |
| 13:30 - 15:00 | [Iteration 1](03-iteration-01.html) Introduction and modifying multiple columns             |
| 15:00 - 15:30 | ‚òï *Coffee break*                                                                           |
| 15:30 - 17:00 | [Iteration 2](04-iteration-02.html) Reading and writing multiple files                      |

## How we will work TOFIX

-   stickies

    -   üü™ I'm all good, I'm done

    -   üüß I could do with some help

-   Discord

-   no stupid questions

-   üé¨ Action!

## Learning Objectives

At the end of this section you will be able to:

::: {style="font-size: 80%;"}
-   explain the rationale for writing functions
-   write vector functions
    -   that take one or more vectors as input and output a vector
    -   that take one or more vectors as input and output a single value
-   specify defaults for function argument
-   write functions that take dataframes as input and output a dataframe
-   using embracing to allow data masking and tidy selection within functions
:::

# Set up

## Project

https://github.com/posit-conf-2023/programming-r-exercises

üé¨ Create a Project:

```{r}
#| eval: false

usethis::use_course("posit-conf-2023/programming-r-exercises")
```

## 

```         
> usethis::use_course("posit-conf-2023/programming-r-exercises")
‚úî Downloading from 'https://github.com/posit-conf-2023/programming-r-exercises/zipball/HEAD'
Downloaded: 0.26 MB  
‚úî Download stored in 'C:/Users/er13/OneDrive - University of York/Desktop/Desktop/posit-conf-2023-programming-r-exercises-978baff.zip'
‚úî Unpacking ZIP file into 'posit-conf-2023-programming-r-exercises-978baff/' (45 files extracted)
Shall we delete the ZIP file ('posit-conf-2023-programming-r-exercises-978baff.zip')?

1: Not now
2: Yeah
3: Nope
```

üé¨ Choose the option that means yes!

## 

```         
‚úî Deleting 'posit-conf-2023-programming-r-exercises-978baff.zip'
‚úî Opening project in RStudio
```

. . .

RStudio will restart

## Create a `.R`

```{r}
#| eval: false

usethis::use_r("functions-01")
```

## Packages

üé¨ Load packages:

```{r}
library(tidyverse)
library(palmerpenguins)
```

```         
‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ
‚úî dplyr     1.1.2     ‚úî readr     2.1.4
‚úî forcats   1.0.0     ‚úî stringr   1.5.0
‚úî ggplot2   3.4.2     ‚úî tibble    3.2.1
‚úî lubridate 1.9.2     ‚úî tidyr     1.3.0
‚úî purrr     1.0.1     ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ
‚úñ dplyr::filter() masks stats::filter()
‚úñ dplyr::lag()    masks stats::lag()
‚Ñπ Use the conflicted package to force all conflicts to become errors'
```

## Load `penguins`

üé¨ Load `penguins` data set

```{r}
data(penguins)
glimpse(penguins)
```

# Why write functions?

## Rationale

-   impact from code: reach and clarity
-   efficiency: update code in one place, decrease error rate, improve ability to reuse

## Example

We have several measurements:

-   `bill_length_mm`
-   `bill_depth_mm`
-   `flipper_length_mm`
-   `body_mass_g`

These are on very different scales

## 

```{r}
#| echo: false
#| layout-ncol: 2

penguins |> ggplot(aes(x = bill_length_mm)) +
  geom_histogram(bins = 20) +
  theme_gray(base_size = 22)
penguins |> ggplot(aes(x = bill_depth_mm)) +
  geom_histogram(bins = 20) +
  theme_gray(base_size = 22)
penguins |> ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(bins = 20) +
  theme_gray(base_size = 22)
penguins |> ggplot(aes(x = body_mass_g)) +
  geom_histogram(bins = 20) +
  theme_gray(base_size = 22)
```

## Example

-   difficult to plot on same axis or determine what value is large for that variable

-   A common solution is to apply a $z$ score transformation to each variable.

-   Normalises the values to have a mean of 0 and a standard deviation of 1

$$z = \frac{x - \bar{x}}{s.d.}$$

## Apply transformation

We can apply the same transformation to each variable:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

## Long, unclear

`(bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE)`

-   Quite a lot of code
-   Difficult to determine what the transformation is

How to shorten and make more clear?

## Coping and pasting

-   is error prone

How to make fewer mistakes?

. . .

Writing a function:

-   can be named to make transformation transparent
-   will make code shorter
-   can be reused

üîëÔ∏è You may think you have to write complex functions - you don't! Start with the simple things.

# Types of function

## Types of function {auto-animate="true"}

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

. . .

2.  data frame functions: df as input and df as output

## Types of function {auto-animate="true"}

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

    i.  output same length as input. "mutate" functions will work well in `mutate()` and `filter()`. Principles of writing functions

    ii. summary functions: input is vector, output is a single value

2.  data frame functions: df as input and df as output

# Vector functions

## Output same length as input

-   output same length as input
-   work well in `mutate()`
-   appropriate for the *z*-transformation example

## General

To turn your code into a function you need:

-   a name
-   the arguments - which represent the bits that vary
-   the code body for the function

. . .

``` r
name <- function(arguments) {
  code body
}
```

## Function name

Use a verb - [The tidyverse style guide](https://style.tidyverse.org/index.html) [@wickham-style] but good advice regardless

. . .

Difficulty in naming? Should this be two or three functions?

. . .

What should we call the function we write to do a $z$ score transformation?

## Arguments

-   the input vector

-   additional arguments

Naming conventions

-   x for the vector input

``` r
name <- function(x) {
  body does things with x
}
```

## Example

$$z = \frac{x - \bar{x}}{s.d.}$$

``` r
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

## Example

Identify the arguments: the things that vary across calls

::: {style="font-size: 60%;"}
``` r
(bill_length_mm    - mean(bill_length_mm,    na.rm = TRUE)) / sd(bill_length_mm,    na.rm = TRUE)
(bill_depth_mm     - mean(bill_depth_mm,     na.rm = TRUE)) / sd(bill_depth_mm,     na.rm = TRUE)
(flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE)
(body_mass_g       - mean(body_mass_g,       na.rm = TRUE)) / sd(body_mass_g,       na.rm = TRUE)
```
:::

\

. . .

::: {style="font-size: 60%;"}
``` r
(üüß - mean(üüß, na.rm = TRUE)) / sd(üüß, na.rm = TRUE)
(üüß - mean(üüß, na.rm = TRUE)) / sd(üüß, na.rm = TRUE)
(üüß - mean(üüß, na.rm = TRUE)) / sd(üüß, na.rm = TRUE)
(üüß - mean(üüß, na.rm = TRUE)) / sd(üüß, na.rm = TRUE)
```
:::

üüß is x

## Example

Put into the template

``` r
name <- function(x) {
  body does things with x
}
```

\

```{r}
to_z <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

## Apply

Rewrite the call to `mutate()` as:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = to_z(bill_length_mm),
    z_bill_depth_mm = to_z(bill_depth_mm),
    z_flipper_length_mm = to_z(flipper_length_mm),
    z_body_mass_g = to_z(body_mass_g)
  )
```

. . .

Much shorter, much more clear.

## A modification

`mean()` has a `trim` argument: `mean(x, trim = 0, na.rm = FALSE, ...)`

*the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed.*

. . .

Suppose we want to specify the *middle* proportion left rather than the proportion trimmed from each end \[\^1\]

## A modification

-   A value of 0.1 for `trim` trims 0.1 from each end leaving 0.8 in the middle

-   trim = (1 - middle)/2

![Trim is the proportion trimmed off each end; middle is what's left](images/vector-functions-trim.png){fig-alt="schematic of trim and middle demonstrating that trim = (1 - middle)/2"}

## Add an argument

```{r}
to_z <- function(x, middle) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

## Try it out

::: {style="font-size: 80%;"}
```{r}
to_z(penguins$bill_length_mm, middle = 0.2)

```
:::

## But what if we forget?

```{r}
#| error: true
to_z(penguins$bill_length_mm)

```

## Give a default

Give defaults whenever possible:

```{r}
to_z <- function(x, middle = 1) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}

```

## Try it out

::: {style="font-size: 80%;"}
```{r}
to_z(penguins$bill_length_mm)
```
:::

## Your turn

üé¨ Write a function that performs the Box-Cox power transformation using the value of (non-zero) lambda ($\lambda$) supplied.

## Your turn: Box-Cox

$$bc = \frac{x^{\lambda} - 1}{\lambda}  \text{ for }\lambda \ne 0$$

-   Set the default $\lambda = 1$

. . .

-   Still have time? Check $\lambda \ne 0$
-   Still have time? Check and amend for:

$$
bc = \begin{cases}
  \frac{x^{\lambda} - 1}{\lambda} & \text{for }\lambda \ne 0\\    
  log(x) & \text{for }\lambda = 0    
\end{cases}
$$

## A solution 1

```{r}
to_box_cox <- function(x, lambda = 1) {
  (x^lambda - 1) / lambda
}
```

## A solution 1 - test

```{r}
vals <- rexp(10000, 10) 
vals |> hist()
```

## A solution 1 - test

```{r}
to_box_cox(vals, 0.3) |> 
  hist()
```

## A solution 2

Check $\lambda \ne 0$

## A solution 3

Check and amend for:

$$
bc = \begin{cases}
  \frac{x^{\lambda} - 1}{\lambda} & \text{for }\lambda \ne 0\\    
  log(x) & \text{for }\lambda = 0    
\end{cases}
$$

## Types of function

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

    i.  ‚úîÔ∏è output same length as input.

    **ii. ‚û°Ô∏è summary functions: input is vector, output is a single value**

2.  data frame functions: df as input and df as output

## Summary functions

-   input is vector
-   output is a single value
-   could be used in `summarise()`

## Example

Write a function to compute the standard error of a sample.

$$s.e. = \frac{s.d.}{\sqrt{n}}$$

## Example

```{r}
sd_error <- function(x){
  sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
}

```

. . .

Note: `sum(TRUE)` = 1 and `sum(FALSE)` = 0 Thus,`sum(!is.na(x))` gives you the number of `TRUE` (i.e., the number of non-NA values) and is a bit shorter than `length(x[!is.na(x)])`

## Try it out

üé¨ Call the function on `penguins$bill_length_mm`

```{r}
sd_error(penguins$bill_length_mm)
```

. . .

Or in a pipeline

```{r}
penguins |> 
  summarise(se = sd_error(bill_length_mm))
```

## Your turn

üé¨ Write a function to compute the sums of squares (sum of the squared deviations from the mean)

$$SS(x) = \sum{(x - \bar{x})^2}$$

or

$$SS(x) = s^2 * (n-1)$$

## A solution - 1

```{r}
sum_sq <- function(x){
 sum((x[!is.na(x)] - mean(x[!is.na(x)]))^2)
}
```


. . . 

üé¨ Try it out

```{r}
sum_sq(penguins$bill_length_mm)
```




## Types of function

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

    i.  ‚úîÔ∏è output same length as input.

    ii. ‚úîÔ∏è summary functions: input is vector, output is a single value

**2.  ‚û°Ô∏è data frame functions: df as input and df as output**



# Dataframe functions

## Dataframe functions

Dataframe as input and Dataframe as output

. . .

We might summarise one of our columns like this:

```{r}
penguins |> 
  summarise(mean = mean(bill_length_mm),
            n = length(bill_length_mm),
            sd = sd(bill_length_mm),
            se = sd_error(bill_length_mm))
```

Output is a dataframe

## 

and want to summarise several in the same way

```{r}
penguins |> 
  summarise(mean = mean(bill_depth_mm),
            n = length(bill_depth_mm),
            sd = sd(bill_depth_mm),
            se = sd_error(bill_depth_mm))
```

Good candidate for a function to avoid repetitive code: `my_summary()`

## Define `my_summary()` function

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean(column),
            n = length(column),
            sd = sd(column),
            se = sd_error(column))
}
```

## Use function

```{r}
#| error: true
my_summary(penguins, bill_length_mm)
```

üòï

## Tidy evaluation

`tidyverse` functions like `dplyr::summarise()` use tidy evaluation so you can refer to the names of variables inside dataframes. For example, you can use:

``` r
penguins |> summarise(mean = mean(bill_depth_mm))
summarise(penguins, mean = mean(bill_depth_mm))
```

rather than

``` r
summarise(penguins, mean = mean(penguins$bill_depth_mm))
```

This is known as data-masking: the dataframe environment masks the user environment by giving priority to the dataframe.

## 

Because of data-masking, `summarise()` in `my_summary()` is looking for a column literally called `column` in the dataframe that has been passed in. It is not looking in the variable `column` for the name of column you want to give it.

[Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html)

## Tidy evaluation

-   easy to code interactively
-   harder to write functions

TODO: decide whether to go in to data masking and tidy selection more

## Fix `my_summary()` function

The solution is to use embracing: {{ var }}

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean({{ column }}),
            n = length({{ column }}),
            sd = sd({{ column }}),
            se = sd_error({{ column }}),
            .groups = "drop")
}
```

. . .

-   look inside `column` variable
-   style with spaces
-   `.groups = "drop"` to avoid message and leave the data in an ungrouped state

## Use function

```{r}
my_summary(penguins, bill_length_mm)
```

üéâ

## When to embrace?

When tidy evaluation is used

## Your turn

üé¨ Write a function to

## Extras

-   Short cuts:

    -   put cursor on a function call and press F2 to find its definition
    -   Ctrl+. opens section/file search

-   Document: Roxygen? ChatGTP?

-   Tests interactive? Unit tests with ChatGTP?

## Summary

## References
