---
title: "useR to programmeR"
subtitle: "👋 & Functions 1"
author: "Emma Rand and Ian Lyttle"
format: 
  revealjs:
    theme: [simple]
    slide-number: true
    chalkboard: true
    code-link: true
    code-line-numbers: false
bibliography: references.bib
---

# 👋 Welcome

## Introductions

This is a two-day, hands-on workshop for those who have embraced the tidyverse and want to build their own packages.

-   Have you written a few of your own R functions?
-   Are you ready to start sharing your code (or data) through R packages?
-   Are you curious what you can do to make your first R packages easy for your users to use, and for you to maintain?

\

### WiFi

-   Username: `conf22`
-   Password: `together!`

## The team

::: columns
::: {.column width="50%"}
Emma Rand 🐦[\@er13_r](https://twitter.com/er13_r)

Stephanie Hazlitt
:::

::: {.column width="50%"}
Ian Lyttle 🐦[\@ijlyttle](https://twitter.com/ijlyttle)

Mouna Belaid
:::
:::

 

Standing on the shoulders of [R for Data Science (2e)](https://r4ds.hadley.nz/) @wickham2023, [The tidyverse style guide](https://style.tidyverse.org/index.html) @wickham

\

### WiFi TOFIX

-   Username: `conf22`
-   Password: `together!`

## Introductions

To each other!

## Code of Conduct TOFIX

[Full Code of Conduct & COVID](https://www.rstudio.com/conference/2022/2022-conf-code-of-conduct/). **Please Review**

-   😷 Please wear a mask
-   💙 Treat everyone with respect
-   🧡 Everyone should feel welcome

Reporting:

-   🗣️ any posit::conf staff member, xxx is our contact
-   📧 `cc@cccccc.com`
-   ☎️ +

## Housekeeping TOFIX

-   WiFi:
    -   Username: `conf22`
    -   Password: `together!`
-   Gender neutral bathrooms xxxxxxxxx.
-   The meditation room is xxxxx. Open 8am - 5pm, Monday - Thursday.
-   The lactation room is located at xxxxx. Open 8am - 5pm, Monday - Thursday.
-   Participants who do not wish to be photographed have red lanyards, please note lanyard colors before taking a photo and respect their choices.

## 🙏 to

-   the TAs

-   colleagues, friends and learners at Schneider Electric, University of York and RForwards!

-   Posit team and especially Mine Çetinkaya-Rundel

. . .

-   Ian!

## Prerequisites TOFIX

You need a laptop with the following installed:

-   R version \>= 4.2 and RStudio \>= 2023.03
-   The following packages:

🎬 Detailed instructions for installing these were covered in [Prerequisites](pre-reqs.qmd)

## Schedule

| Time          | Activity                                                                                                          |
|:----------------------------------|:------------------------------------|
| 09:00 - 10:30 | [Functions 1](01-functions-01.html) Introduction, vector and dataframe functions, indirection and tidy evaluation |
| 10:30 - 11:00 | *Coffee break*                                                                                                    |
| 11:00 - 12:30 | [Functions 2](02-functions-02.html) Plot functions, style and side effects                                        |
| 12:30 - 13:30 | *Lunch break*                                                                                                     |
| 13:30 - 15:00 | [Iteration 1](03-iteration-01.html) Introduction and modifying multiple columns       |
| 15:00 - 15:30 | *Coffee break*                                                                                                    |
| 15:30 - 17:00 | [Iteration 2](04-iteration-02.html) Reading and writing multiple files                |

## How we will work

-   stickies

    -   🟪 I'm all good, I'm done

    -   🟧 I could do with some help

-   Discord

-   no stupid questions

-   🎬 Action! (today)

## Learning Objectives

::: small
At the end of this section you will be able to:

-   xx
-   x
-   x
-   x
:::

# Set up

## Project and Packages

🎬 Create a Project:

```{r}
#| eval: false

usethis::create_project("workshop-functions")
```

🎬 Load packages:

```{r}
library(tidyverse)
library(palmerpenguins)
```

## Data

🎬 Load `penguins` data set

```{r}
data(penguins)
glimpse(penguins)
```

# Why write functions?

## Rationale

-   impact from code: reach and clarity
-   efficiency: update code in one place, decrease error rate, improve ability to reuse

## Example

We have several measurements `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm` and `body_mass_g`

```{r}
#| echo: false
#| layout-ncol: 2
penguins |> ggplot(aes(x = bill_length_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = bill_depth_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(bins = 20) 
penguins |> ggplot(aes(x = body_mass_g)) +
  geom_histogram(bins = 20) 
```

These are on very different scales

## Example

A common solution is to apply a $z$ score transformation to each variable which normalises the values to have a mean of 0 and a standard deviation of 1

$$z = \frac{x - \bar{x}}{s.d.}$$

## Example

We can apply the same transformation to each variable:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

How to shorten and make more clear: `(bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE)`

## Coping and pasting

1.  Error prone
2.  Difficult to follow: more code than needed, difficult to determine what the transformation is

key point: you may think you have to write complex functions - you don't, start with the simple things.

# Types of function

## Types of function

We will cover two types of function

1.  vector functions: one of more vectors as input, one vector as output

    i.  output same length as input. "mutate" functions will work well in `mutate()` and `filter()`. Principles of writing functions

    ii. summary functions: input is vector, output is a single value

2.  data frame functions: df as input and df as output

# Vector functions

## Output same length as input

-   output same length as input
-   work well in `mutate()`
-   appropriate for the example

## General

To turn your code into a function you need:

-   a name
-   the arguments - which represent the bits that vary
-   the code body for the function

``` r
name <- function(arguments) {
  code body
}
```

## Function name

Use a verb - The tidyverse style guide @wickham but good advice regardless

Difficulty in naming? Should this be two or three functions?

. . .

What should we call the function we write to do a $z$ score transformation?

## Arguments

-   the input vector

-   additional arguments

Naming conventions

-   x for the vector input

``` r
name <- function(x) {
  body does things with x
}
```

## Example

$$z = \frac{x - \bar{x}}{s.d.}$$

``` r
penguins <- penguins |>
  mutate(
    z_bill_length_mm = (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) / sd(bill_length_mm, na.rm = TRUE),
    z_bill_depth_mm = (bill_depth_mm - mean(bill_depth_mm, na.rm = TRUE)) / sd(bill_depth_mm, na.rm = TRUE),
    z_flipper_length_mm = (flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE),
    z_body_mass_g = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE)
  )
```

## Example

Identify the arguments: the things that vary across calls

``` r
 
(bill_length_mm    - mean(bill_length_mm,    na.rm = TRUE)) / sd(bill_length_mm,    na.rm = TRUE)
(bill_depth_mm     - mean(bill_depth_mm,     na.rm = TRUE)) / sd(bill_depth_mm,     na.rm = TRUE)
(flipper_length_mm - mean(flipper_length_mm, na.rm = TRUE)) / sd(flipper_length_mm, na.rm = TRUE)
(body_mass_g       - mean(body_mass_g,       na.rm = TRUE)) / sd(body_mass_g,       na.rm = TRUE)
```

. . .

``` r
 
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
(🟧 - mean(🟧, na.rm = TRUE)) / sd(🟧, na.rm = TRUE)
```

🟧 is x

## Example

Put into the template

```{r}
to_z <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

## Apply

Rewrite the call to`mutate()` as:

```{r}
penguins <- penguins |>
  mutate(
    z_bill_length_mm = to_z(bill_length_mm),
    z_bill_depth_mm = to_z(bill_depth_mm),
    z_flipper_length_mm = to_z(flipper_length_mm),
    z_body_mass_g = to_z(body_mass_g)
  )
```

. . .

Much shorter, much more clear.

## A modification

`mean()` has a `trim` argument: `mean(x, trim = 0, na.rm = FALSE, ...)`

*the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed.*

Suppose we want to specify the **middle** proportion left rather than the proportion trimmed from each end\[\^1\]

![Trim is the proportion trimmed off each end; middle is what's left](images/vector-functions-trim.png){fig-alt="schematic of trim and middle demonstflipper_length_mming that trim - (1 - middle)/2"}

## Add an argument

```{r}
to_z <- function(x, middle) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

Try it out

```{r}
to_z(penguins$bill_length_mm, middle = 0.2)
```

But what if we forget?

```{r}
#| error: true
to_z(penguins$bill_length_mm)
```

## Give a default

Give defaults whenever possible:

```{r}
to_z <- function(x, middle = 1) {
  trim = (1 - middle)/2
  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)
}
```

Try it out

```{r}
to_z(penguins$bill_length_mm)
```

## Your turn

🎬 Write that performs the Box-Cox power transformation using the value of (non-zero) lambda ($\lambda$) supplied.

$$bc = \frac{x^{\lambda} - 1}{\lambda}$$


## A solution

```{r}

```



## Summary functions

-   input is vector
-   output is a single value
-   could be used in `summarise()`

## Example

Write a function to compute the standard error of a sample.

$$s.e. = \frac{s.d.}{\sqrt{n}}$$

## Example

```{r}
sd_error <- function(x){
  sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
}

```

Note: `sum(TRUE)` = 1 and `sum(FALSE)` = 0 `sum(!is.na(x))` is a bit sorter than `length(x[!is.na(x)])`

## 

```{r}
sd_error(penguins$bill_length_mm)
```

```{r}
penguins |> 
  summarise(se = sd_error(bill_length_mm))
```

## Your turn

🎬 Write a function to compute the sums of squares (sum of the squared deviations from the mean)

$$SS(x) = \sum{(x - \bar{x})^2}$$

or

$$SS(x) = s^2 * (n-1)$$

## $SS(x)$

```{r}
sum_sq <- function(x){
 sum((x[!is.na(x)] - mean(x[!is.na(x)]))^2)
}
```

```{r}
sum_sq(penguins$bill_length_mm)
```

# Dataframe functions

## Dataframe functions

Dataframe as input and Dataframe as output

. . .

We might summarise one of our columns like this:

```{r}
penguins |> 
  summarise(mean = mean(bill_length_mm),
            n = length(bill_length_mm),
            sd = sd(bill_length_mm),
            se = sd_error(bill_length_mm))
```

Output is a dataframe

## 

and want to summarise several in the same way

```{r}
penguins |> 
  summarise(mean = mean(bill_depth_mm),
            n = length(bill_depth_mm),
            sd = sd(bill_depth_mm),
            se = sd_error(bill_depth_mm))
```

Good candidate for a function to avoid repetitive code: `my_summary()`

## Define `my_summary()` function

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean(column),
            n = length(column),
            sd = sd(column),
            se = sd_error(column))
}
```

## Use function

```{r}
#| error: true
my_summary(penguins, bill_length_mm)
```

😕

## Tidy evaluation

`tidyverse` functions like `dplyr::summarise()` use tidy evaluation so you can refer to the names of variables inside dataframes. For example, you can use:

``` r
penguins |> summarise(mean = mean(bill_depth_mm))
summarise(penguins, mean = mean(bill_depth_mm))
```

rather than

``` r
summarise(penguins, mean = mean(penguins$bill_depth_mm))
```

This is known as data-masking: the dataframe environment masks the user environment by giving priority to the dataframe.

## 

Because of data-masking, `summarise()` in `my_summary()` is looking for a column literally called `column` in the dataframe that has been passed in. It is not looking in the variable `column` for the name of column you want to give it.

[Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html)

## Tidy evaluation

-   easy to code interactively
-   harder to write functions

TODO: decide whether to go in to data masking and tidy selection more

## Fix `my_summary()` function

The solution is to use embracing: {{ var }}

```{r}
my_summary <- function(df, column){
  df |> 
  summarise(mean = mean({{ column }}),
            n = length({{ column }}),
            sd = sd({{ column }}),
            se = sd_error({{ column }}),
            .groups = "drop")
}
```

. . .

-   look inside `column` variable
-   style with spaces
-   `.groups = "drop"` to avoid message and leave the data in an ungrouped state

## Use function

```{r}
my_summary(penguins, bill_length_mm)
```

🎉

## When to embrace?

When tidy evaluation is used

## Your turn

🎬 Write a function to

## Extras

-   Short cuts:

    -   put cursor on a function call and press F2 to find its definition
    -   Ctrl+. opens section/file search

-   Document: Roxygen? ChatGTP?

-   Tests interactive? Unit tests with ChatGTP?

## Summary
